package com.jlb.tools.logging;

import java.io.File;
import java.io.IOException;
import java.net.InetAddress;
import java.net.URL;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.Locale;
import java.util.ResourceBundle;

import org.apache.log4j.Appender;
import org.apache.log4j.FileAppender;
import org.apache.log4j.Level;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.log4j.MDC;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.RollingFileAppender;

/**
 * This class aims to instanciate ISigmaLogger objects. The log4j initialization
 * is performed in a static way, at the class initialization. The default file
 * for log4j init is "log4j.properties".
 *
 * If the default file is found in a "resources" subdirectory of the class path,
 * then the log4 configuration will be overriden with properties defined in this
 * very file. If no log4j.properties fil is found in the classpath, the default
 * file is used instead.
 */
public class LoggerFactory implements Log4jProperties {

	/**
	 * Name of the default configuration file for log4j.
	 */
	public static final String LOG4J_CONFIGURATION_FILE = "log4j";

	/** Default Log4j file extension. */
	public static final String LOG4J_CONFIGURATION_FILE_EXT = ".properties";

	/**
	 * Logger de console
	 */
	public static final String CONSOLE_LOGGER = "ConsoleLogger";
	/**
	 * Console appender
	 */
	public static final String CONSOLE_APPENDER = "ConsoleAppender";

	/**
	 * Logger de Roulement de fichiers
	 */
	public static final String ROLLING_FILE_LOGGER = "RollingFileLogger";
	/**
	 * Roulement de fichier appender
	 */
	public static final String ROLLING_FILE_APPENDER = "RollingFileAppender";

	/** Maximum size of files generated by the RollingFileAppender */
	private static String defaultMaxFileSize;

	/** Maximum number of backup files used by the RollingFileAppender */
	private static int defaultMaxBackupIndex;

	/** Directory for log files. */
	private static File defaultLogDir;

	/** Default encoding for log files. */
	private static String defaultEncoding;

	/** Default layout. */
	private static String defaultPattern;

	/** Flag in order to know that initialized() has been successfuly called. */
	private static boolean isInitialized;

	/** Map containing all created RollingFileAppender objets. */
	private static HashMap<String, RollingFileAppender> myMapOfRollingAppenders;

	private static boolean initialize(ClassLoader cl) {
		myMapOfRollingAppenders = new HashMap<String, RollingFileAppender>();

		ResourceBundle configFileResource = null;
		try {
			configFileResource = ResourceBundle.getBundle("resources." + LOG4J_CONFIGURATION_FILE, Locale.getDefault(),
					cl);

			URL url = cl.getResource("resources/" + LOG4J_CONFIGURATION_FILE + LOG4J_CONFIGURATION_FILE_EXT);

			if (url != null) {
				PropertyConfigurator.configure(url);
			} else {
				System.out.println("[INFO] No optional log4j.properties found in the classpath.");
			}
		} catch (Throwable t) {
			// Normal, caused by ResourceBundle.getBundle()
			System.out.println("[INFO] No optional log4j.properties found in the classpath.");
		}

		// Chargement des proprietes log4j de l'utilisateur (ou celles par
		// defaut si aucun fichier optionnel n'est fourni)
		if (configFileResource != null) {

			// Look for the property LOG_DIR
			String property = getBundleString(configFileResource, LOG_DIR);
			if (property != null && property.length() > 0) {
				defaultLogDir = new File(property.trim());
			}

			// Look for the property ROLLING_MAX_BACKUP_INDEX
			property = getBundleString(configFileResource, ROLLING_MAX_BACKUP_INDEX);
			if (property != null && property.length() > 0) {
				try {
					defaultMaxBackupIndex = Integer.parseInt(property.trim());
				} catch (NumberFormatException t) {
				}
			}

			// Look for the property ROLLING_MAX_FILE_SIZE
			property = getBundleString(configFileResource, ROLLING_MAX_FILE_SIZE);
			if (property != null && property.length() > 0) {
				defaultMaxFileSize = property.trim();
			}

			// Look for the property LOG_ENCODING
			property = getBundleString(configFileResource, LOG_ENCODING);
			if (property != null && property.length() > 0) {
				defaultEncoding = property.trim();
			}

			// Look for the property LOG_PATTERN
			property = getBundleString(configFileResource, LOG_PATTERN);
			if (property != null && property.length() > 0) {
				defaultPattern = property.trim();
			}
		} else
			return false;

		if (defaultLogDir != null && defaultLogDir.exists() == false) {
			defaultLogDir.mkdirs();
		}
		return true;
	}

	/**
	 * Util method because ResourceBundle.getString() throws exceptions if the
	 * searched property is not found.
	 */
	private static String getBundleString(ResourceBundle bundle, String property) {
		// ResourceBundle.getString() lance une exception si la propriete
		// recherchee n'est pas presente...
		try {
			return bundle.getString(property);
		} catch (Throwable t) {
			return null;
		}
	}

	/**
	 * Retourne le RollingFileAppender qui se trouve en cache ou bien en cree un
	 * nouveau.
	 * 
	 * @param filename
	 *            Nom du fichier de sortie des logs.
	 * @return Le RollingFileAppender en cache ou bien un nouveau.
	 * @throws IOException
	 *             Si la construction du RollingFileAppender ne marche pas.
	 */
	private static RollingFileAppender getRollingAppender(String filename) throws IOException {
		RollingFileAppender appender = myMapOfRollingAppenders.get(filename);
		if (appender == null) {
			PatternLayout layout = new PatternLayout(defaultPattern);
			RollingFileAppender newAppender = new RollingFileAppender(layout, filename);
			newAppender.setMaxBackupIndex(defaultMaxBackupIndex);
			newAppender.setMaxFileSize(defaultMaxFileSize);
			newAppender.setEncoding(defaultEncoding);
			newAppender.setName(ROLLING_FILE_APPENDER);
			newAppender.activateOptions();
			myMapOfRollingAppenders.put(filename, newAppender);
			return newAppender;
		}
		return appender;
	}

	/**
	 * Creates a logger that will write in a file dedicated to the component
	 * given in argument.
	 * <p>
	 * The logger's name must be the same name as defined in the
	 * log4j.properties file. The default file can be overriden with a
	 * user-defined file placed in a "resources" directory of the classpath.
	 * </p>
	 * <p>
	 * If any problem occurs, this method will log a message in System.err and
	 * return a logger that will print messages in System.out.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> if the logger is unknown, log4j creates a new
	 * logger that inherits from the root logger and will redirect messages in
	 * appenders of the root logger.
	 * </p>
	 * 
	 * @param componentName
	 *
	 * @param loggerName
	 *            The logger's name as defined in log4j.properties (or usually a
	 *            class name if no log4j file is provided).
	 *
	 * @return A brand new logger able to log messages on the local machine.
	 */
	public static ILogger createLogger(String componentName, String loggerName) {
		// A partir du rootLogger, on recupere le repository afin de savoir
		// si l'utilisateur a fourni un fichier de conf log4j avec un logger
		// nomme '<loggerName>'. Si oui, alors on n'influe pas du tout sur son
		// objet. Par contre si aucun logger de ce nom n'existe dans le fichier
		// de conf, alors on le cree (ses proprietes heriteront du rootLogger)
		// et on lui ajoute un appender.

		if (isInitialized == false) {
			isInitialized = initialize(ClassLoader.getSystemClassLoader());
		}
		if (isInitialized == false) {
			throw new Error("LoggerFactory is not correctly initialized. See error output for details.");
		}

		// Il faut initialiser ces variables dans le thread courant.
		try {
			InetAddress addr = InetAddress.getLocalHost();
			MDC.put(MDC_KEY_HOSTNAME, addr.getHostName());
			MDC.put(MDC_KEY_HOSTADDRESS, addr.getHostAddress());
		} catch (UnknownHostException e) {
			MDC.put(MDC_KEY_HOSTNAME, "localhost");
			MDC.put(MDC_KEY_HOSTADDRESS, "127.0.0.1");
		}

		Logger existingLogger = LogManager.exists(loggerName);

		if (existingLogger != null) {
			return new ILoggerImpl(existingLogger);
		}

		String filename =
		// Repertoire de logs
		defaultLogDir.getAbsolutePath() + File.separator +
				// <HOST>_<CSC>.log
				MDC.get(LoggerFactory.MDC_KEY_HOSTNAME).toString().toUpperCase() + '_' + componentName.toUpperCase()
				+ ".LOG";

		Logger logger = Logger.getLogger(loggerName);

		// Si on est sur que les traces sont activees, alors on ajoute un
		// RollingFileAppender au logger. Sinon on retourne le logger tel quel
		// et aucun fichier ne sera genere.
		Logger rootLogger = Logger.getRootLogger();

		if (rootLogger.getLevel().equals(Level.OFF)) {
			return new ILoggerImpl(logger);
		}

		// Si le logger a deja un appender "RollingFileAppender", pas la peine
		// d'ajouter le notre encore une fois.
		if (logger.getAppender(ROLLING_FILE_APPENDER) != null) {
			return new ILoggerImpl(logger);
		}

		try {
			logger.addAppender(getRollingAppender(filename));
		} catch (IOException e) {
			e.printStackTrace();
			logger.error("Unable to create a new file for logger " + loggerName, e);
		}

		return new ILoggerImpl(logger);
	}

	/**
	 * Creates a logger with only one appender that will write out messages in
	 * the file specified in 'outputFileName' argument.
	 * <p>
	 * The logger's name must be the same name as defined in the
	 * log4j.properties file. The default "log4j.properties" configuration file
	 * can be overriden with a user-defined file placed in a "resources"
	 * directory of the classpath.
	 * </p>
	 * <p>
	 * If any problem occurs, this method will return a logger that will print
	 * messages in the standard output.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> if the logger is unknown, log4j creates a new
	 * logger that inherits from the root logger and will redirect messages in
	 * the "FileAppender" appender. If the logger is defined and already has an
	 * appender, this appender will be kept but another "FileAppender" will be
	 * added to this logger.
	 * </p>
	 * 
	 * @param componentName
	 *
	 * @param logDirectory
	 *            The directory where log files will be written.
	 * @param loggerName
	 *            The logger's name as defined in log4j.properties.
	 * @param outputFileName
	 *            The logger's output file (relative to logDirectory).
	 * @return A brand new logger able to log messages on the local machine.
	 */
	public static ILogger createLogger(String componentName, String loggerName, File logDirectory,
			String outputFileName) {
		if (isInitialized == false) {
			isInitialized = initialize(ClassLoader.getSystemClassLoader());
		}
		if (isInitialized == false) {
			throw new Error("LoggerFactory is not correctly initialized. See error output for details.");
		}

		// Il faut initialiser ces variables dans le thread courant.
		try {
			InetAddress addr = InetAddress.getLocalHost();
			MDC.put(MDC_KEY_HOSTNAME, addr.getHostName());
			MDC.put(MDC_KEY_HOSTADDRESS, addr.getHostAddress());
		} catch (UnknownHostException e) {
			MDC.put(MDC_KEY_HOSTNAME, "localhost");
			MDC.put(MDC_KEY_HOSTADDRESS, "127.0.0.1");
		}

		// Si le nom est fourni en absolu c'est une erreur. Il faut passer par
		// la methode "initialize()" afin de specifier le repertoire de
		// destination des logs. Donc on remet 'outputFileName' en relatif.
		if (outputFileName.contains("/")) {
			outputFileName = outputFileName.substring(outputFileName.lastIndexOf('/') + 1);
		}
		if (outputFileName.contains("\\")) {
			outputFileName = outputFileName.substring(outputFileName.lastIndexOf('\\') + 1);
		}
		outputFileName = logDirectory.getAbsolutePath() + File.separator + MDC.get(LoggerFactory.MDC_KEY_HOSTNAME) + '_'
				+ outputFileName;

		// A partir du rootLogger, on recupere le repository afin de savoir
		// si l'utilisateur a fourni un fichier de conf log4j avec un logger
		// nomme <loggerName>. Si oui, on lui ajoute simplement un appender.
		// Sinon, on cree un nouveau logger et on lui ajoute un appender pour
		// ecrire dans le fichier precise en argument.

		Logger rootLogger = Logger.getRootLogger();

		// On regarde si le logger existe ou pas...
		Logger existingLogger = LogManager.exists(loggerName);

		if (existingLogger == null) {
			// Il n'existe pas donc on en cree un nouveau
			existingLogger = Logger.getLogger(loggerName);
			existingLogger.setAdditivity(false);
		}

		// Si le logger a deja un appender "RollingFileAppender", pas la peine
		// d'ajouter le notre encore une fois. Par contre il faut modifier le
		// fichier de sortie pour que les traces aillent dans le fichier
		// demande.
		if (existingLogger.getAppender(ROLLING_FILE_APPENDER) != null) {
			Appender appender = existingLogger.getAppender(ROLLING_FILE_APPENDER);
			if (appender instanceof RollingFileAppender) {
				RollingFileAppender rollingAppender = (RollingFileAppender) appender;
				rollingAppender.setFile(outputFileName);
				rollingAppender.activateOptions();
			}
			return new ILoggerImpl(existingLogger);
		}

		Appender rootAppender = rootLogger.getAppender(ROLLING_FILE_APPENDER);
		if (rootAppender != null && rootAppender instanceof FileAppender) {
			// l'utilisateur a deja un RollingFileAppender associe au
			// rootLogger.
			// On prend celui la et on lui change juste le nom de fichier
			((FileAppender) rootAppender).setFile(outputFileName);
			((FileAppender) rootAppender).activateOptions();
		} else {
			// On ajoute un nouveau FileAppender au logger de l'utilisateur
			try {
				existingLogger.addAppender(getRollingAppender(outputFileName));
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		return new ILoggerImpl(existingLogger);
	}

	/**
	 * Creates a logger that will write in a file dedicated to the component
	 * given in argument.
	 * <p>
	 * The logger's name must be the same name as defined in the
	 * log4j.properties file. The default file can be overriden with a
	 * user-defined file placed in a "resources" directory of the classpath.
	 * </p>
	 * <p>
	 * If any problem occurs, this method will log a message in System.err and
	 * return a logger that will print messages in System.out.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> if the logger is unknown, log4j creates a new
	 * logger that inherits from the root logger and will redirect messages in
	 * appenders of the root logger.
	 * </p>
	 *
	 * @param cl
	 *            Classloader to use so as to look for the resource bundle
	 *            log4j.properties.
	 * @param componentName
	 * @param loggerName
	 *            The logger's name as defined in log4j.properties (or usually a
	 *            class name if no log4j file is provided).
	 *
	 * @return A brand new logger able to log messages on the local machine.
	 */
	public static ILogger createLogger(ClassLoader cl, String componentName, String loggerName) {
		// A partir du rootLogger, on recupere le repository afin de savoir
		// si l'utilisateur a fourni un fichier de conf log4j avec un logger
		// nomme '<loggerName>'. Si oui, alors on n'influe pas du tout sur son
		// objet. Par contre si aucun logger de ce nom n'existe dans le fichier
		// de conf, alors on le cree (ses proprietes heriteront du rootLogger)
		// et on lui ajoute un appender.

		if (isInitialized == false) {
			isInitialized = initialize(cl);
		}
		if (isInitialized == false) {
			throw new Error("LoggerFactory is not correctly initialized. See error output for details.");
		}

		// Il faut initialiser ces variables dans le thread courant.
		try {
			InetAddress addr = InetAddress.getLocalHost();
			MDC.put(MDC_KEY_HOSTNAME, addr.getHostName());
			MDC.put(MDC_KEY_HOSTADDRESS, addr.getHostAddress());
		} catch (UnknownHostException e) {
			MDC.put(MDC_KEY_HOSTNAME, "localhost");
			MDC.put(MDC_KEY_HOSTADDRESS, "127.0.0.1");
		}

		Logger existingLogger = LogManager.exists(loggerName);

		if (existingLogger != null) {
			return new ILoggerImpl(existingLogger);
		}

		String filename =
		// Repertoire de logs
		defaultLogDir.getAbsolutePath() + File.separator +
				// <HOST>_<CSC>.log
				MDC.get(LoggerFactory.MDC_KEY_HOSTNAME).toString().toUpperCase() + '_' + componentName.toUpperCase()
				+ ".LOG";

		Logger logger = Logger.getLogger(loggerName);

		// Si on est sur que les traces sont activees, alors on ajoute un
		// RollingFileAppender au logger. Sinon on retourne le logger tel quel
		// et aucun fichier ne sera genere.
		Logger rootLogger = Logger.getRootLogger();

		if (rootLogger.getLevel().equals(Level.OFF)) {
			return new ILoggerImpl(logger);
		}

		// Si le logger a deja un appender "RollingFileAppender", pas la peine
		// d'ajouter le notre encore une fois.
		if (logger.getAppender(ROLLING_FILE_APPENDER) != null) {
			return new ILoggerImpl(logger);
		}

		try {
			logger.addAppender(getRollingAppender(filename));
		} catch (IOException e) {
			e.printStackTrace();
			logger.error("Unable to create a new file for logger " + loggerName, e);
		}

		return new ILoggerImpl(logger);
	}

	/**
	 * Creates a logger with only one appender that will write out messages in
	 * the file specified in 'outputFileName' argument.
	 * <p>
	 * The logger's name must be the same name as defined in the
	 * log4j.properties file. The default "log4j.properties" configuration file
	 * can be overriden with a user-defined file placed in a "resources"
	 * directory of the classpath.
	 * </p>
	 * <p>
	 * If any problem occurs, this method will return a logger that will print
	 * messages in the standard output.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> if the logger is unknown, log4j creates a new
	 * logger that inherits from the root logger and will redirect messages in
	 * the "FileAppender" appender. If the logger is defined and already has an
	 * appender, this appender will be kept but another "FileAppender" will be
	 * added to this logger.
	 * </p>
	 *
	 * @param cl
	 *            Classloader to use so as to look for the resource bundle
	 *            log4j.properties.
	 * @param componentName
	 * @param logDirectory
	 *            The directory where log files will be written.
	 * @param loggerName
	 *            The logger's name as defined in log4j.properties.
	 * @param outputFileName
	 *            The logger's output file (relative to logDirectory).
	 * @return A brand new logger able to log messages on the local machine.
	 */
	public static ILogger createLogger(ClassLoader cl, String componentName, String loggerName, File logDirectory,
			String outputFileName) {
		if (isInitialized == false) {
			isInitialized = initialize(cl);
		}
		if (isInitialized == false) {
			throw new Error("LoggerFactory is not correctly initialized. See error output for details.");
		}

		// Il faut initialiser ces variables dans le thread courant.
		try {
			InetAddress addr = InetAddress.getLocalHost();
			MDC.put(MDC_KEY_HOSTNAME, addr.getHostName());
			MDC.put(MDC_KEY_HOSTADDRESS, addr.getHostAddress());
		} catch (UnknownHostException e) {
			MDC.put(MDC_KEY_HOSTNAME, "localhost");
			MDC.put(MDC_KEY_HOSTADDRESS, "127.0.0.1");
		}

		// Si le nom est fourni en absolu c'est une erreur. Il faut passer par
		// la methode "initialize()" afin de specifier le repertoire de
		// destination des logs. Donc on remet 'outputFileName' en relatif.
		if (outputFileName.contains("/")) {
			outputFileName = outputFileName.substring(outputFileName.lastIndexOf('/') + 1);
		}
		if (outputFileName.contains("\\")) {
			outputFileName = outputFileName.substring(outputFileName.lastIndexOf('\\') + 1);
		}
		outputFileName = logDirectory.getAbsolutePath() + File.separator + MDC.get(LoggerFactory.MDC_KEY_HOSTNAME) + '_'
				+ outputFileName;

		// A partir du rootLogger, on recupere le repository afin de savoir
		// si l'utilisateur a fourni un fichier de conf log4j avec un logger
		// nomme <loggerName>. Si oui, on lui ajoute simplement un appender.
		// Sinon, on cree un nouveau logger et on lui ajoute un appender pour
		// ecrire dans le fichier precise en argument.

		Logger rootLogger = Logger.getRootLogger();

		// On regarde si le logger existe ou pas...
		Logger existingLogger = LogManager.exists(loggerName);

		if (existingLogger == null) {
			// Il n'existe pas donc on en cr�e un nouveau
			existingLogger = Logger.getLogger(loggerName);
			existingLogger.setAdditivity(false);
		}

		// Si le logger a d�j� un appender "RollingFileAppender", pas la
		// peine
		// d'ajouter le notre encore une fois. Par contre il faut modifier le
		// fichier de sortie pour que les traces aillent dans le fichier
		// demand�.
		if (existingLogger.getAppender(ROLLING_FILE_APPENDER) != null) {
			Appender appender = existingLogger.getAppender(ROLLING_FILE_APPENDER);
			if (appender instanceof RollingFileAppender) {
				RollingFileAppender rollingAppender = (RollingFileAppender) appender;
				rollingAppender.setFile(outputFileName);
				rollingAppender.activateOptions();
			}
			return new ILoggerImpl(existingLogger);
		}

		Appender rootAppender = rootLogger.getAppender(ROLLING_FILE_APPENDER);
		if (rootAppender != null && rootAppender instanceof FileAppender) {
			// l'utilisateur a deja un RollingFileAppender associe au
			// rootLogger.
			// On prend celui l� et on lui change juste le nom de fichier
			((FileAppender) rootAppender).setFile(outputFileName);
			((FileAppender) rootAppender).activateOptions();
		} else {
			// On ajoute un nouveau FileAppender au logger de l'utilisateur
			try {
				existingLogger.addAppender(getRollingAppender(outputFileName));
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		return new ILoggerImpl(existingLogger);
	}
}
